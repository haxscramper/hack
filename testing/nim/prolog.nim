import sequtils
import sugar
import hashes
import hmisc/[defensive, helpers]
import macros
import options
import strutils, strformat
import tables

initDefense()

##[

Test implementaiton of prologs backtracking and unification
algorithms. This is only a test implementation.

High-level overview of logic:

- List of all clauses in workspace
- User issues a query with zero or more unbound variables
- Solver tries to find clause that maches user query (head is unified
  with query and body is evaluated as true)
- Environment with variable values is returned

During 'solution' all clauses in workspace are tried in order of their
insertion.

]##

type
  Failure* = ref object of CatchableError

type
  ClauseId* = distinct int
  ValueType* = string
  Symbol* = string


  TermKind* = enum
    tkConstant
    tkVariable
    tkFunctor

  Term* = object
    case kind*: TermKind
      of tkConstant:
        value*: ValueType ## Constant value

      of tkVariable:
        name*: Symbol ## Name of the variable
        genIdx*: int ## Number of times variable has been copied.
                    ## Increased with each `copy`

      of tkFunctor:
        symbol*: Symbol ## Name of the functor
        arguments*: seq[Term] ## List of arguments
        copied*: bool ## Term generated by `copy`

  Variable = Term

  Environment* = object
    ## Mapping between variables and values. Variable is not
    ## necessarily mapped to constants/terms directly - binding chain
    ## in form `(K1, V1), (V1, "final")` might exist
    values: Table[Term, Term]

  Block* = object
    # idx*: int
    current*: int ## Index of currently active alternative in list of alternatives
    alts*: seq[(ClauseId, Environment)] ## List of alternatives - when
    ## more than one goal matches for query unification all possible
    ## alternatives have to be considered too. They are stored in this
    ## field. `ClauseId` is a

type
  Clause = object
    id: ClauseId ## Clause it. It is used for referencing this value
                 ## in clause store in environment.
    head: Term ## Head term of a clause. Used for unification and
    body: seq[Term] ## List of subgoals. They will be proved during
                    ## goal solutio

  Program = object
    clauses: seq[ClauseId]

func `==`(c1, c2: ClauseId): bool =
  int(c1) == int(c2)

func `<`(c1, c2: ClauseId): bool =
  int(c1) < int(c2)

type
  # TODO REFACTOR remove this - it serves no purpose
  ClauseStore = object
    data: OrderedTable[ClauseId, Clause]

type
  WorkspaceT = object
    ## Represents environment in which queries are evaluated.
    clauseStore: ClauseStore ## List of all clauses defined in workspace

  Workspace = var WorkspaceT

proc `[]`(w: Workspace, cl: ClauseId): var Clause =
  ## Get reference to clause in workspace
  w.clauseStore.data[cl]


proc hash(t: Term): Hash =
  ## Hash for term.
  # XXXX NOTE if performance issues are encountered this might be the
  # first proc to optimize.
  var h: Hash = 0
  h = h !& int(t.kind)
  case t.kind:
    of tkVariable:
      h = h !& hash(t.name) !& hash(t.genIdx)
    of tkConstant:
      h = h !& hash(t.value)
    of tkFunctor:
      h = h !& hash(t.copied)
      for arg in t.arguments:
        h = h !& hash(arg)

  result = !$h

proc registerClause(w: Workspace, cl: Clause): void =
  ## Add clause to store in workspace
  w.clauseStore.data[cl.id] = cl

proc getClause(w: Workspace, id: ClauseId): Clause =
  ## Get clause with matching clause id from workspace clause store.
  w.clauseStore.data[id]

func hasAlts(bl: Block): bool =
  ## Check if block has alternatives
  bl.current < bl.alts.len

template anyOfIt(s: typed, pr: untyped): bool =
  ## Check if for any of the elements in sequence predicate `pr`
  ## evaluates as true. variable `it` is injected into scope
  var res = false
  for it {.inject.} in s:
    if pr:
      res = true
      break

  res

type
  ControlStack = seq[Block] ## Sequences of control blocks. Used to
                            ## revert environment values using
                            ## backtracking and keep track of clauses
                            ## that will be tried next when
                            ## backtracking

func hasAlts(bl: ControlStack): bool =
  ## Check if any of the blocks in control stack has alternatives
  bl.anyOfIt(it.hasAlts)

func findAlt(bl: ControlStack): int =
  ## Find index of block in controls stack with is not finished.
  bl.findIt(it.hasAlts)

func getAlt(bl: ControlStack): (ClauseId, Environment) =
  ## Get alternative from topmost block in control stack. It is
  ## searched from top to bottom. NOTE: if no alternatives is present
  ## exception will be raised.
  let idx = bl.findAlt()
  assert idx > -1, "Cannot get alternative from finished block"

  let choice = bl[idx]
  return choice.alts[choice.current]


func getAlt(bl: Block): (ClauseId, Environment) =
  ## Get clause id and unification environment for current
  ## alternative. NOTE: will throw exception if no more alternatives
  ## are present.
  assert bl.hasAlts(), "Attempt to get alternative from finished block"
  return bl.alts[bl.current]

func nextAlt(bl: var Block): void =
  ## Move block to next alternative. This increases alt pointer by one
  ## - explicit check for `hasAlts` is necessary in subsequent
  ## accesses using procs such as `getEnv`, `getAlt` etc.
  inc bl.current

func getEnv(bl: Block): Environment =
  ## Get environment from currently active alternative in block
  bl.getAlt()[1]

func isFact(cl: Clause): bool =
  ## Check if clause is a fact (has no body)
  cl.body.len == 0

func isVar(term: Term): bool =
  ## Check if term is a variable
  term.kind == tkVariable

func isConstant*(term: Term): bool =
  ## Check if term is a constant
  term.kind == tkConstant

func isFunctor*(term: Term): bool =
  ## Check if term is a functor
  term.kind == tkFunctor

func isGenvar*(term: Term): bool =
  ## Check if variable is generated using `copy`
  assert term.isVar()
  return term.genIdx > 0

func isCopied*(term: Term): bool =
  ## Check if functor was copied
  assert term.isFunctor()
  return term.copied

func sameName*(cl: Clause, term: Term): bool =
  ## Check if clause has the same name as term
  cl.head.symbol == term.symbol

func arity*(term: Term): int =
  ## Number of parameters in functional term
  assert term.isFunctor()
  return term.arguments.len

func sameTerm*(t1, t2: Term): bool =
  ## Check if two terms are **identical**, regardless of the
  ## environemtn value.
  if t1.kind != t2.kind:
    return false

  case t1.kind:
    of tkConstant:
      return t1.value == t2.value
    of tkVariable:
      return t1.name == t2.name
    of tkFunctor:
      if t1.symbol == t2.symbol and t1.arity() == t2.arity():
        for (arg1, arg2) in zip(t1.arguments, t2.arguments):
          if not sameTerm(arg1, arg2):
            return false

        return true
      else:
        return false


func `==`(t1, t2: Term): bool = sameTerm(t1, t2)
proc makeEnvironment*(values: seq[(Term, Term)] = @[]): Environment =
  ## Create new environment using `values` as initial binding values
  result = Environment(values: values.toTable())

proc makeFunctor*(functorName: string, args: seq[Term]): Term =
  ## Create new functor term
  Term(kind: tkFunctor, symbol: functorName, arguments: args)

proc makeClause*(head: Term, body: seq[Term]): Clause =
  ## Create new clause
  assert head.isFunctor()
  for goal in body:
    assert goal.isFunctor()

  var idx {.global.}: int
  inc idx
  return Clause(
    id: ClauseId(idx),
    head: head,
    body: body
  )

proc makeStoreClause*(head: Term, body: seq[Term], w: Workspace): ClauseId =
  ## Create new clause using `head` as clause head and body as list of
  ## subgoals, then add it to workspace. Return id of newly generated
  ## clause.
  let cl = makeClause(head, body)
  w.registerClause(cl)
  return cl.id

iterator iterateClauses*(w: Workspace): ClauseId =
  ## Iterate over all clauses in workspace
  for id, cl in w.clauseStore.data:
    yield id

proc makeVariable*(varName: string): Term =
  ## Create new variable
  Term(kind: tkVariable, name: varName)


proc makeFreeVar*(): Term =
  ## Create `#free#` variable
  var freeVarInst {.global.}: Term
  freeVarInst = makeVariable("#free#")
  freeVarInst

proc makeChoice*(# idx: int,
                 alts: seq[(ClauseId, Environment)]): Block =
  ## Create choice block
  Block(# idx: idx,-
        alts: alts, current: 0)

proc makeConstant*(constValue: ValueType): Term =
  ## Create constant term
  Term(kind: tkConstant, value: constValue)

iterator pairs*(env: Environment): (Term, Term) =
  ## Iterate over pairs of values in environment
  for key, val in env.values:
    yield (key, val)

iterator items*(env: Environment): (Term, Term) =
  ## Iterate over pairs `(key, val)` in environment
  for key, val in env.values:
    yield (key, val)

func contains*(env: Environment, variable: Variable): bool =
  ## Check if environment contains variable
  for v, val in env:
    if sameTerm(v, variable):
      result = true

proc getVarList*(term: Term): seq[Variable] =
  ## Output list of all variables in term
  case term.kind:
    of tkConstant:
      return @[]
    of tkVariable:
      return @[term]
    of tkFunctor:
      concat(term.arguments.map(getVarList))


iterator iterateVars*(term: Term): Variable =
  ## Iterate all variables in term
  for v in term.getVarList():
    yield v

iterator iterateVars*(cl: Clause): Variable =
  ## Traverse all free variables in clause in order of their
  ## appearance in. Values appearhing two times are yielded twice.
  # NOTE might be necessary to ignore duplicates
  for arg in cl.head.iterateVars():
    yield arg

  for goal in cl.body:
    for v in goal.iterateVars():
      yield v

func getValue*(env: Environment, term: Variable): Option[Term] =
  ## Return value of term in environment or `none`
  if env.values.hasKey(term):
    return some(env.values[term])

  return none(Term)

func `[]`(env: Environment, term: Variable): Term =
  ## Get value of term from environment. Can throw exception if `term`
  ## is not present in environment
  env.values[term]

proc isBound*(term: Variable, env: Environment): bool =
  ## Check if variable is bound to some value in the environment.
  ## Variable is considered free if it is bound to itself, to `#free#`
  ## variable or not present in environment at all. Binding chain
  ## traversal is not performed.
  let val = env.getValue(term)
  return (val.isSome() and # Present in environment
    not (
      sameTerm(val.get(), makeFreeVar()) or # Not explicitly bound to free var
      sameTerm(val.get(), term) or # Not bound to itself
      val.get().isVar() # NOTE ???
    ))


proc `$`*(term: Term): string =
  case term.kind:
    of tkConstant:
      return "'" & term.value & "'"
    of tkVariable:
      return "_" & term.name & "'".repeat(term.genIdx)
    of tkFunctor:
      return term.symbol & "(" & term.arguments.mapIt($it).join(", ") & ")"

proc `$`*(env: Environment): string =
  "{" & env.mapIt(
    &"({it[0]} " & (
      (it[0].isVar() and it[1].isVar()).tern("<->", "->")
    ) & &" {it[1]})"
  ).join(" ") & "}"

proc `$`*(cl: Clause): string =
  if cl.isFact():
    $cl.head & "."
  else:
    $cl.head & " :- " & cl.body.mapIt($it).join(", ") & "."

proc `$`*(id: ClauseId): string = $int(id)

proc push(
  self: var Environment, variable: Variable,
  value: Term, noOverride: bool = true): void =
  ## Add pair `variable -> value` to the environment
  if noOverride:
    assert not isBound(variable, self),
       &"""Attempt to rebind already existing var '{variable}' to '{value}'
  (current binding is '{self.getValue(variable).get()}')"""
  else:
    discard
    # TODO drop values
    # if variable.isBound(self):
    #   self.values.delete(
    #     findIt(sameTerm(it[0], variable))
    #   )

  self.values[variable] = value

proc pushEnv(bl: var Block, v: Variable, val: Term, noOverride = true): void =
  ## Add new variable to current alternative block
  bl.alts[bl.current][1].push(v, val, noOverride)

proc genVar(term: Variable): Variable =
  ## Create new variable from `term`
  assert term.isVar()
  result = term
  inc result.genIdx

proc dereference(term: Term, env: Environment): Term =
  ## Traverse binding chain in environment `env` and return value of
  ## the `term`
  result = term

  while result.isBound(env):
    let value = env.getValue(result).get()
    if value.isConstant() or sameTerm(value, result):
      result = value
      break

    result = value

proc bindTerm(variable, value: Term, env: Environment): Environment

proc copy(term: Term, env: Environment): (Term, Environment) =
  ## Create copy of a term. All variables are replaced with new ones.
  let inputEnv = env
  case term.kind:
    of tkConstant:
      return (term, inputEnv)
    of tkVariable:
      let deref = term.dereference(env)
      if deref.isVar():
        let newVar = term.genVar()
        var resEnv = bindTerm(deref, newVar, env)
        return (newVar, resEnv)
      else:
        return (deref, inputEnv)

    of tkFunctor:
      var resEnv = env
      var resFunctor = makeFunctor(term.symbol, @[])
      for arg in term.arguments:
        let (tmpArg, tmpEnv) = arg.copy(resEnv)
        resEnv = tmpEnv
        resFunctor.arguments.add tmpArg

      assert resFunctor.arity() == term.arity()
      return (resFunctor, resEnv)

# proc copy(cl: Clause): (ClauseId, Environment) =
#   ## Create copy of a clause
#   var resEnv: Environment
#   for v in cl.iterateVars():
#     if v notin resEnv:
#       resEnv.push(v, makeFreeVar())

#   return (cl.id, resEnv)


proc bindTerm(variable, value: Term, env: Environment): Environment =
  ## Create environment where `variable` is bound to `value`
  result = env
  case value.kind:
    of tkConstant, tkVariable:
      result.push(variable, value)
    of tkFunctor:
      if value.isCopied:
        result.push(variable, value)
      else:
        let (newTerm, newEnv) = value.copy(env)
        result = newEnv
        result.push(variable, newTerm)


converter toVariable(term: Term): Variable =
  ## Convert term to variable
  assert term.kind == tkVariable
  return term

template last[T](s: seq[T]): T =
  ## Reference last item in sequence
  s[^1]


proc logBlock(bl: Block): void =
  for alt in bl.alts:
    showLog &"id: {alt[0]}, env: {alt[1]}"



proc equalConstants(t1, t2: Term): bool =
  ## Check if two constants has equal value
  (t1.kind == tkConstant) and (t2.kind == tkConstant) and (t1.value == t2.value)

proc unif(t1, t2: Term, env: Environment = makeEnvironment()): Environment =
  ## If possible, return new environment where two terms `t1`, `t2` are equal
  let
    val1 = dereference(t1, env)
    val2 = dereference(t2, env)

  if val1.isConstant() and val2.isConstant():
    if equalConstants(val1, val2):
      return env
    else:
      raise Failure(msg: "Unification failed: different constants")
  elif val1.isVar():
    return bindTerm(val1, val2, env)
  elif val2.isVar():
    return bindTerm(val2, val1, env)
  else:
    result = env
    if val1.symbol != val2.symbol:
      raise Failure(
        msg: &"Cannot unify functors with different names '{t1}' and '{t2}'")

    for (arg1, arg2) in zip(val1.arguments, val2.arguments):
      result = unif(arg1, arg2, result)



iterator getUnified(w: Workspace, term: Term, env: Environment): (ClauseId, Environment) =
  ## Iterate over all clauses in workspace `w` that can be unified
  ## with term `t` under existing environment `env`.
  for cl in w.iterateClauses():
    if w[cl].sameName(term) and (w[cl].head.arity() == term.arity()):
      try:
        let resEnv = unif(term, w[cl].head, env)
        yield (cl, resEnv)
      except Failure:
        # showWarn "Clause", w[cl], ": ", getCurrentExceptionMsg()
        discard




proc revert*(call, head: Term, env: Environment): Environment =
  ## Given original goal `call` and clause head `head` infer values of
  ## variables from `call`. `env` is an environment in which `head`
  ## evaluates as true.
  ## .. code::
  ##   echo revert(
  ##     "e".makeFunctor(@[makeVariable "X", makeVariable "Y"]),
  ##     "e".makeFunctor(@[makeVariable "I", "g".makeFunctor(@[makeVariable "I"])]),
  ##     makeEnvironment(@[(makeVariable "I", makeConstant "2")])
  ##   )
  ## Outputs: `{(_X -> '2') (_Y -> g('2'))}`


  discard unif(call, head)

  let (cpTerm, cpEnv) = head.copy(env)
  let resEnv = unif(call, cpTerm, cpEnv)

  let exported = collect(newSeq):
    for v in call.iterateVars():
      (v, resEnv[v])

  return makeEnvironment(exported)



proc solve*(w: Workspace, query: Term, topEnv: Environment): Option[(ClauseId, Environment)] =
  ## If solution is possible, return matching clause id and it's
  ## environment
  var control: ControlStack = @[makeChoice(# idx = -1,
                                           alts = toSeq(w.getUnified(query, topEnv)))]
  showInfo "Solving ", query, "in env", topEnv
  while control.hasAlts():
    let topId = control[0].getAlt()[0]
    # Iterate over all clauses that match toplevel query
    let (cl, env) = control.getAlt()
    let subMax = w[topId].body.len - 1
    if w[cl].isFact():
      showLog &"Found fact {w[cl]} with env {env}"
      return some((cl, env))
    else:
      let subgoals = w[cl].body
      var idx = (control.len - 2).clamp(0, control.len)
      showLog &"Control contains {control.len} block"
      while idx < subgoals.len:
        let subgoal = subgoals[idx]
        let nowEnv = control.last.getEnv()

        showInfo &"Solving subgoal #{idx}, {subgoal}. Adding block to control"
        control.add @[makeChoice(# idx = idx,
                                 alts = toSeq(w.getUnified(subgoal, nowEnv)))]
        runIndentedLog:
          let solution = w.solve(subgoal, nowEnv)

        if solution.isSome():
          let (solId, resEnv) = solution.get()
          let revEnv = revert(subgoal, w[control.last.getAlt()[0]].head, resEnv)
          showLog "Can retrieve value", revEnv
          for v, val in revEnv:
            control.last.pushEnv(v, val, false)

          if idx == subMax:
            showInfo "Final goal in clause, returning result"
            return some((cl, control.last.getEnv()))
          else:
            showLog &"Goal #{idx} solved, moving to #{idx + 1}"
            inc idx
        else:
          showWarn "Subgoal solution failed"
          if not control.last.hasAlts():
            showLog "Last block has no more alternative solutions, backtracking ..."
            # Remove choice point from the top of the stack: we tried everything
            showLog &"Control contains {control.len} blocks, discarding top one"
            discard control.pop
            dec idx
            # Advance choice point under current one
            control.last.nextAlt()
            # Break the loop - it is not possible to solve current
            # subgoal under this condition, we need to try earlier
            break
          else:
            showLog "Last block has alternative solutions"
            control.last.nextAlt()

proc solveValues(w: Workspace, query: Term, env: Environment = makeEnvironment()): Option[Environment] =
  ## Solve `query` in workspace `w` using optional environment `env`.
  ## Resulting environment contains values for all free variables
  ## present in query.
  let solution = w.solve(query, env)
  if solution.isSome():
    let (solId, solEnv) = solution.get()
    return some(revert(
      call = query,
      head = w[solId].head,
      env = solEnv
    ))



proc mf(s: string, a: varargs[Term]): Term = makeFunctor(s, toSeq(a))
proc mv(n: string): Term = makeVariable(n)
proc mc(s: string): Term = makeConstant(s)

proc main() =
  if false:
    echo unif(
      t1 = "t".mf(mv("X"), "f".mf(mv("U"), mv("Z"))),
      t2 = "t".mf(mc("12"), "f".mf(mc("--"), mv("I"))),
      env = makeEnvironment()
    )

    echo unif(
      t1 = "e".mf(mv "X", mv "Y"),
      t2 = "e".mf(mv "X", mv "X"),
      env = makeEnvironment()
    )

    echo dereference(mv("X"), makeEnvironment(
      values = @[(mv("X"), mc("*&&*"))]
    ))


    echo dereference(mv("X"), makeEnvironment(
      values = @[
        (mv("X"), mv("Y")),
        (mv("Y"), mc("*&&*"))]
    ))


  if true:

    var w: WorkspaceT
    let prog = Program(
      clauses: @[
        makeStoreClause("p".mf(mv "X1"),
                        @["q".mf(mv "X1", mv "Y1"),
                          "r".mf(mv "Y1")], w),
        makeStoreClause("q".mf(mc "a", mc "b"), @[], w),
        makeStoreClause("q".mf(mv "Z", mc "c"), @[], w),
        makeStoreClause("r".mf(mc "c"), @[], w),
        makeStoreClause(
          "c".mf(mv "X", mv "Y"),
          @["c1".mf(mv "Y")# , "c2".mf(mv "Y")
          ], w
        ),
        makeStoreClause("c1".mf(mv "Z"), @["e".mf(mv "Z", mc "2")], w),
        makeStoreClause("c1".mf(mv "Z"), @["e".mf(mv "Z", mc "3")], w),
        makeStoreClause("c2".mf(mv "Z"), @["e".mf(mv "Z", mc "5")], w),
        makeStoreClause("c2".mf(mv "Z"), @["e".mf(mv "Z", mc "6")], w),
        makeStoreClause("e".mf(mv "I", mv "I"), @[], w),
        makeStoreClause("f".mf(mc "2"), @[], w),
      ]
    )

    showInfo "Solving 'p(a)'"
    runIndentedLog:
      showLog w.solveValues("p".mf(mc "a"))

    showInfo "Query solutions"
    runIndentedLog:
      let query = mf("c", @[mc "2", mv "U"])
      let (solId, solEnv) = w.solve(query, makeEnvironment()).get()
      showLog "Result clause__:", w[solId]
      showLog "Result env_____:", solEnv
      showLog "Query vars_____:", revert(
        call = query,
        head = w[solId].head,
        env = solEnv
      )

    showInfo "Simple solver"
    showLog w.solveValues("f".mf(mv "Y"))


    echo copy("e".mf(mv "X", mv "Y"), makeEnvironment(@[(mv "X", mc "2")]))

    echo unif("e".mf(mc "2", mc "2"), "e".mf(mc "2", mv "U"))
    echo unif("e".mf(mv "X", mv "Y"), "e".mf(mc "2", mv "U"))
    echo unif("e".mf(mc "2", mv "U"), "e".mf(mv "X", mv "Y"))
    proc revertTest(t1, t2: Term, env: Environment): void =
      showInfo "Revert"
      runIndentedLog:
        showLog "Called as_________:", t1
        showLog "Unification head__: ", t2
        showLog "Clause res env____: ", env
        let rev = revert(t1, t2, env)
        showLog "Retrieved values__: ", rev

    revertTest(
      "e".mf(mv "X", mv "Y"),
      "e".mf(mv "I", mv "I"),
      makeEnvironment(@[(mv "I", mc"2")])
    )

    revertTest(
      "e".mf(mv "X", mv "X"),
      "e".mf(mv "I", mv "I"),
      makeEnvironment(@[(mv "I", mc"2")])
    )

    revertTest(
      "e".mf(mv "X", mv "Y"),
      "e".mf(mv "I", "g".mf(mv "I")),
      makeEnvironment(@[(mv "I", mc"2")])
    )

    revertTest(
      "e".mf(mv "X", "f".mf(mv "Y")),
      "e".mf(mv "I", "f".mf(mv "Z")),
      makeEnvironment(@[(mv "I", mc "2"), (mv "Z", mc "*")])
    )




pprintErr:
  main()
