#+setupfile: ~/.config/hax-config/emacs/latex-export-header.org
#+author: Артемов Максим ИВБО-02-18
#+title: Работа 4 по дисциплине "ОиХД"

* Диаграмма DFD

* Диаграмма IDEF0

#+caption: Первый уровень ~IDEF0~ диаграммы
#+attr_latex: :float nil
[[file:idef-level-1.tmp.png]]

#+caption: Второй уровень ~IDEF0~ диаграммы
#+attr_latex: :float nil
[[file:idef-level-1.tmp.png]]

* Диаграмма IDEF3

* ~SQL~

Была разработана программа для анализа исходного кода других программ.
Программа представляет из себя интерактивный интерпретатор комманд,
способный производин считывание, распознавание (~A1~ на ~IDEF0~
диаграмме) и анализ (~A2~ на ~IDEF0~ диаграмме) исходного кода и
построение базы данных, хранящей информацию полученное при анализе.

Интерпретатор распознаеь следующие комманды:

- ~loadf~ :: производит загрузку файла с исходным кодом, его обработку
  и добавление в базу данных. Данная комманда реализует блоки ~A1~,
  ~A2~ и ~A3~ на ~IDEF0~ диаграмме.
- ~uses~ :: Выводит список функций которые принимают объект данного
  типа в качестве одного из аргументов. Позволяет получить информацию
  о том как можно "использовать" объекты данного типа.
- ~get~ :: Выводит списко функций которые которые возвращают объект
  данного типа. Предназначена для нахождения способов "получить"
  объект определенного типа.
- ~signature~ :: Позволяет производить поиск фукнции с определенной
  сигнатурой в базе данных.

Все комманды генерируют запрос к текущей базе объектов и выводит
результат в человекочитаемом формате.

** Пример файла для обработки

Файл использованный в качестве тестового для примеров:

#+include: "example.nim" src nim

** ~signature~

*** Описание синтаксиса

Комманда ~signature~ принимает в качестве аргумента строку в
следующего вида[fn::синтаксис указания сигнатуры функций частично
позаимствован ~Haskell~ и математики (в математике функция меджу
множествами описывается как \(F \colon S_1 \times S_2 \mapsto O\))]:
~<glob> :: [<types>] -> <return>~, где
- ~<glob>~ :: ~SQL~ glob паттерн для имени функции. Предназначен для
  указания шаблона имени функции. Например, в том случае если нужно
  найти функцию, чье имя начинается с ~get~ то необходимое значение
  параметра ~<glob>~ - ~get*~
- ~[<types>]~ :: список типов - аргументов функций. Аргументы
  разделены строкой ~" X "~. При обработке данной комманды разделение
  аргументов на списко происдит именно по этой строке так что наличие
  пробелов явлется обязательным условием. Пример: ~int X string~ -
  позволяет пользователю найти функцию которая принимает ~int~ и
  ~string~ в качестве аргумента.
- ~<return>~ :: тип возвращяемого значения.

NOTE: ~::~ и ~->~ являются обязательным частями синтаксиса комманды.

*** Пример использование комманды

Допустим пользователю требуется найти функцию которая позволяет
получить строку (~string~) из объекта типа ~Object~. В таком случае
пользователь должен ввести комманду ~signature name :: Object ->
string~. Возможный результаты обработки:


#+caption: Результат обоработки ~signature name :: Object -> string~
#+begin_src txt
======================================= found =======================================

    name(o: Object): string

======================================== end ========================================
#+end_src

*** Описание реализации комманды

При обработке данной комманды составлется запрос следующего вида:

Для каждого типа в аргументе функции составлется подзапрос:

#+begin_src sql
SELECT procid FROM arguments WHERE type = '{arg}'
GROUP BY procid, type HAVING COUNT(type) = {cnt}
#+end_src

Где в ~{arg}~ подставлется тип аргумента а в ~{cnt}~ количество
аргументов одного типа.

После чего данные подзапросы объединяются при помощи ~UNION~ и
генерируется конечный запрос:

#+begin_src sql
  SELECT procname, procid, rettype FROM procs
  WHERE procid IN (
        {unionQuery}
  )
  AND procname GLOB '{name}'
  AND rettype = '{ret}';
#+end_src

Где ~{unionQuery}~ - результат объединения подкомманд для аргументов,
~{name}~ паттерн для имени функции, ~{ret}~ - тип возвращемого
значениея. 

#+caption: Пример сгенерированного запроса
#+begin_src sql
  SELECT procname, procid, rettype FROM procs
  WHERE procid IN (
      SELECT procid FROM arguments WHERE type = 'int'
      GROUP BY procid, type HAVING COUNT(type) = 1
    UNION
      SELECT procid FROM arguments WHERE type = 'string'
      GROUP BY procid, type HAVING COUNT(type) = 2
  )
  AND procname GLOB 'get*'
  AND rettype = 'int';
#+end_src

Данный запрос были сгенерирован в результате выполнения комманды
~signature get* :: string X string X int -> int~
