import common
import algorithm
import parsetoml
import strutils
import key_codes
import report
import sequtils
import hmisc/helpers
import colechopkg/types
import algorithm
import tables
import sets
import hmisc/helpers

## .. include:: notes.rst

type
  KeyState* = enum
    kstChangedPressed ## Previously unmodified now pressed
    kstChangedReleased ## Previously pressed now released
    kstIdlePressed ## Previously pressed no change now
    kstIdleReleased ## Not pressed no change


  KeyPress* = object ## Report modifications generated by single key press
    modifiers*: set[HIDModifiers] ## Added modifiers
    code*: KeyCode ## Generated key

  KeyResult* = object ##[ Key press events to be generated after key
  pressed/released ]##

    case isFinal*: bool ## final keys are exported immediately upon
                        ## triggering.
    of true:
      chord*: seq[KeyPress] ## Set of keypresses will be executed
                            ## immediately when key is pressed
      acceptModifiers*: bool ## Whether or not to account for already
                             ## pressed modifiers in generated event
    of false:
      adder*: KeyPress ##[ Modifications of the current key will be
      included to current buffer for output even ]##

    modifiers*: HashSet[string] ##[ Modifiers exported when the key is
    pressed ]##

    # IDEA add support for custom modifiers that change behaviour of
    # different keys. For example, I can have 'math' modifier that
    # will make `>` insert unicode left arrow (using compose key).
    # Regular modifier keys can be also converted to affect keypresses
    # generated by various keys.

  ModifierMap* = Table[HashSet[string], KeyResult] ##[ Mapping between
    different modifiers and results]##

  Key* = object
    state*: KeyState ## Current state of the key

    onPress*: ModifierMap ##[ Mapping between current modifiers and
    possible press actions generated by the key ]##

    onRelease*: ModifierMap ##[ Mapping between current modifiers and
    possible release actions generated by the key ]##

  KeyGrid* = object

    keyGrid*: seq[seq[Key]] ##[ 2d grid of keys. Dimensions should be
    identical to the `[rowPins][colPins]` ]##

    rowPins*: seq[int] ##[ Physical pins to scan rows ]##
    colPins*: seq[int] ##[ Physical pins to scan columns ]##


func getActivatedChord(
  key: Key, modifiers: HashSet[string], onPress: bool = true
     ): Option[KeyResult] =
    ## Return `KeyResult` from the modifier map matching `modifiers`.
    ## If there is no matching entry for specified modifiers `none` is
    ## returned.
    let trigger = onPress.tern(key.onPress, key.onRelease)

    if trigger.hasKey(modifiers):
      some(trigger[modifiers])
    else:
      none(KeyResult)

const defaultMods: tuple[
  ctrl, alt, shift, meta, default: string
] = (
    ctrl: "ctrl",
    alt: "alt",
    shift: "shift",
    meta: "meta",
    default: "default"
)
proc makeModifierMap(
  keybind: string|seq[KeyPress],
  makeFinal: bool = false,
  addDefault: bool = true
     ): ModifierMap =
  ##[ Generate modifier map for single target keybinding represented
  as either string or sequence of key presses.

  :makeFinal: whether or not to make resulting key final. Final keys
  are exported immediately upon triggering, non-final ones are added
  to accumulated modifiers. If you want to make button that works
  performs solely as modifier you need to have `makeFinal = false`. If
  you are interested in mapping button to more complex key combination
  and don't want to react to already pressed modifiers use `makeFinal
  = true`.

  :addDefault: whether or not to add all possible combinations of
  default modifier combinations (16 in total) to resulting keymap. If
  you are creating one of the default keys (letters, numbers etc.) and
  want to have them react correctly to other modifiers from the start
  use `addDefault = true`.

  ]##

  let chords: seq[KeyPress] =
    when keybind is string:
      decodeKeybindingStr(keybindingStr).mapIt(it.toKeyResult)
    else:
      keybind

  if addDefault:
    # Single key, generate all default keys
    for comb in @[@["default"]] & allSubsets(@["ctrl", "shift", "alt", "meta"]):
      var res = KeyResult(
        isFinal: false,
        modifiers: toHashSet(comb),
        adder: KeyPress(code: chords[0].code)
      )

      for modif in comb:
        case modif:
          of defaultMods.ctrl:
            res.adder.modifiers.incl hmLeftCtrl

          of defaultMods.alt:
            res.adder.modifiers.incl hmLeftAlt

          of defaultMods.shift:
            res.adder.modifiers.incl hmLeftShift

          of defaultMods.meta:
            res.adder.modifiers.incl hmLeftMeta

      result[toHashSet(comb)] = res
  else:
    # Multiple keys, generate final chord
    discard


func toHIDReport*(press: KeyPress): HIDReport =
  result.modifiers = press.modifiers
  result.keycodes[0] = press.code

func toKeyPress*(code: (KeyCode, set[HIDModifiers])): KeyPress =
  KeyPress(
    code: code[0],
    modifiers: code[1]
  )

func toKeyPress*(code: KeyCode): KeyPress =
  if code.isModifier():
    result.modifiers.incl code.toHIDModifer()
  else:
    result.code = code

func toKeybindingStr*(key: KeyResult): string =
  ## Return key press result in form of emacs chord
  if key.isFinal:
    result = key.chord.mapIt(it.toHIDReport().toKeybindingStr).join(" ")
  else:
    result = key.adder.toHIDReport().toKeybindingStr()


func notDefaultModifier(modif: string): bool =
  return modif notin @["default", "ctrl", "shift", "alt", "meta"]


func toKeybindingStr*(key: ModifierMap, printAll: bool = false): seq[string] =
  for it in key.keys():
    if printAll or anyofIt(it, it.notDefaultModifier()):
      result.add $it & " -> " & key[it].toKeybindingStr()

  result = result.sortedByIt(it.len)



type
  Seq2D[T] = seq[seq[T]]
  Seq3D[T] = seq[seq[seq[T]]]

# IDEA add support for arranging string grids relative to ech other
# (above, below etc), centerin them in terminal and so on. Not
# full-blown curses-like graphics, just very simple string
# manipluations.

# IDEA add support for printing grid transitions - output two grid
# states and highlight changed keys.
proc printGrid*(grid: KeyGrid) =
  ## Print matrix keys as 2d array. Keys are mapped to emacs notation
  ## and. Multi-chord keys are mapped as multiple keypresses. NOTE:
  ## Currently only on-release events are printed.
  let matrix: Seq3D[string] = grid.keyGrid.mapIt(it.mapIt(
    it.onPress.toKeybindingStr(true)
  ))

  proc maxLen[T](s: Seq3D[T]): int =
    # echo s
    s.mapIt( # 3d
      it.mapIt( # 2d
        it.mapIt( # 1d
          it.len
        ).max(0)
      ).max(0)
    ).max(0)

  let colWidth = maxLen(matrix) + 2
  echo "+", matrix[0].mapIt("-".repeat(colWidth)).join("+"), "+"
  for row in matrix:
    static: assert row is Seq2d[string]

    let rowHeight: int = row.mapIt(it.len).max(0)
    for line in 0 ..< rowHeight:

      let lItems = row.
        mapIt((it.len <= line).tern("", it[line])).
        mapIt(center(it, colWidth))

      let lStr = "|" & lItems.mapIt($it).join("|") & "|"
      echo lStr

    let rSep = "+" & row.mapIt("-".repeat(colWidth)).join("+") & "+"
    echo rSep


proc updateKey*(key: var Key, isPressed: bool): bool =
  ## Transition between key states based on whether or not it is
  ## pressed
  # IDEA write macro for function that perform role of state automata.
  # Provide DSL for writing transition rules (base it on some language
  # that is related to automata)
  result = false

  case key.state:
    of kstIdleReleased:
      if isPressed:
        key.state = kstChangedPressed
        result = true # Key is now pressed

    of kstIdlePressed:
      if not isPressed:
        key.state = kstChangedReleased
        result = true # Key is not released

    of kstChangedPressed:
      if isPressed:
        key.state = kstIdlePressed
        # Key is still pressed, no changes

    of kstChangedReleased:
      if not isPressed:
        # Key is still released, no changes
        key.state = kstIdleReleased


proc hasDifferentValues[T](arr: seq[T]): bool =
  var sorted = arr
  sorted.sort()
  for idx, item in sorted[1 ..^ 1]:
    if sorted[idx] == item:
      return false

  return true

func makeKeyPress(
  code: KeyCode = ccKeyNone, modifiers: set[HIDModifiers]): KeyPress =
  ## Make single key press instance with key and modifiers
  var modifs: set[HIDModifiers]
  for m in modifiers:
    modifs.incl m
  KeyPress(code: code, modifiers: modifs)

func makeKeyResult*(
  chords: seq[tuple[code: KeyCode, modifs: set[HIDModifiers]]]
     ): KeyResult =
  if chords.len == 1:
    KeyResult(
      isFinal: false,
      adder: makeKeyPress(chords[0].code, chords[0].modifs)
    )
  else:
    KeyResult(
      isFinal: true,
      chord: chords.mapIt(makeKeyPress(it.code, it.modifs))
    )

const noMod*: set[HIDModifiers] = {}
proc makeKeyGrid*(
  codes: seq[seq[ # 2d grid
    seq[(KeyCode, set[HIDModifiers])] # Key configurations
  ]],
  rowPins, colPins: seq[int]
     ): KeyGrid =
  assert codes.len == rowPins.len
  assert codes[0].len == colPins.len
  assert rowPins.hasDifferentValues()
  assert colPins.hasDifferentValues()

  KeyGrid(
    keyGrid: codes.mapIt(
      it.mapIt(Key(
        state: kstIdleReleased,
        onPress: makeModifierMap(it.mapIt(it.toKeyPress)))
      )),
    rowPins: rowPins,
    colPins: colPins)



proc parseGridConfig*(str: string): KeyGrid =
  let toml = str.parseString()
  assert toml.hasKey("rowPins")
  assert toml.hasKey("colPins")

  let codes: seq[seq[seq[(KeyCode, set[HIDModifiers])]]] =
    toml["row"].getElems().mapIt(
      it["keys"].getElems().mapIt(
        it.getStr().decodeKeybindingStr()))

  return makeKeyGrid(
    rowPins = toml["rowPins"].getElems().mapIt(it.getInt()),
    colPins = toml["colPins"].getElems().mapIt(it.getInt()),
    codes = codes
  )

proc updateKeyGrid*(grid: var KeyGrid, matrixState: seq[seq[bool]]): bool =
  ## Determine whether or not any change ocurred in grid (based on
  ## matrixState). Return true if at least one key chaged. Grid will
  ## be modified to match new state (key states will be updated)
  var anyChanges = false

  for rowIdx, rowState in matrixState:
    for keyIdx, keyState in rowState:
      let key = grid.keyGrid[rowIdx][keyIdx]
      let isChanged = grid.keyGrid[rowIdx][keyIdx].updateKey(keyState)
      # echo key.state, " -> ",
      #     grid.keyGrid[rowIdx][keyIdx].state, " ",
      #     key.onPress.toKeybindingStr()
      anyChanges = anyChanges or isChanged

  return anyChanges

proc createReports*(grid: KeyGrid): seq[HIDReport] =
  ## Generate report based on current grid status. Because some
  ## buttons might generate multiple keypresses (chord bindings)
  ## multiple hid reports are returned.
  # TODO comment case-of for key state switching
  var keys: seq[KeyCode]
  var accumulatedReport: HIDReport
  var currentModifiers: HashSet[string]
  for keyRow in grid.keyGrid:
    for key in keyRow:
      if key.state in @[kstChangedPressed, kstIdlePressed]:
        let newMods = key.getActivatedChord(currentModifiers, onPress = true)

      case key.state:
        of kstChangedPressed, kstChangedReleased:
          # echo "key state is ", key.state
          let kResOpt: Option[KeyResult] = (key.state == kstChangedPressed).tern(
            key.getActivatedChord(currentModifiers, onPress = true),
            key.getActivatedChord(currentModifiers, onPress = false)
          )

          iflet (kRes = kResOpt):
            if kRes.isFinal:
              # TODO accept buffered modifiers
              # NOTE returning immediately on multi-chort button
              return kRes.chord.map(toHIDReport)
            else:
              accumulatedReport.modifiers.incl kRes.adder.modifiers
              # TODO account for multiple keys, use all six slots to
              # generate output event
              accumulatedReport.keycodes[0] = kRes.adder.code
          else:
            echo "No matching keybindings for ", currentModifiers
        else:
          discard

  return @[accumulatedReport]
