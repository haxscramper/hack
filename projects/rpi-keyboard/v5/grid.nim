import common
import parsetoml
import strutils
import key_codes
import report
import sequtils
import hmisc/helpers
import colechopkg/types
import algorithm
import tables
import sets
import hmisc/helpers

type
  KeyState* = enum
    kstChangedPressed ## Previously unmodified now pressed
    kstChangedReleased ## Previously pressed now released
    kstIdlePressed ## Previously pressed no change now
    kstIdleReleased ## Not pressed no change

  KeyPress* = object ## Report modifications generated by single key press
    modifiers*: set[HIDModifiers] ## Added modifiers
    code*: KeyCode ## Generated key

  KeyResult* = object ## Key press events to be generated after key
                      ## pressed/released
    case isFinal*: bool
    of true:
      chord*: seq[KeyPress] ## Set of keypresses will be executed
                            ## immediately when key is pressed
      acceptModifiers*: bool ## Whether or not to account for already
                             ## pressed modifiers in generated event
    of false: adder*: KeyPress ## Modifications of the current key
                               ## will be included to current buffer
                               ## for output even

    # IDEA add support for custom modifiers that change behaviour of
    # different keys. For example, I can have 'math' modifier that
    # will make `>` insert unicode left arrow (using compose key).
    # Regular modifier keys can be also converted to affect keypresses
    # generated by various keys.

  ModifierMap* = Table[HashSet[string], KeyResult]

  Key* = object
    state*: KeyState ## Current state of the key

    modifiers*: HashSet[string] ## Modifiers exported when the key is
                                ## pressed

    onPress*: ModifierMap ## Mapping between current modifiers and
                          ## possible press actions generated by the
                          ## key

    onRelease*: ModifierMap ## Mapping between current modifiers and
                            ## possible release actions generated by
                            ## the key

  KeyGrid* = object
    keyGrid*: seq[seq[Key]]
    rowPins*: seq[int]
    colPins*: seq[int]

func getActivatedChord(
  key: Key, modifiers: HashSet[string], onPress: bool = true
     ): Option[KeyResult] =
    ## Return `KeyResult` from the modifier map matching `modifiers`.
    ## If there is no matching entry for specified modifiers `none` is
    ## returned.
    let trigger = onPress.tern(key.onPress, key.onRelease)

    if trigger.hasKey(modifiers):
      some(trigger[modifiers])
    else:
      none(KeyResult)

proc makeModifierMap(
  keybind: string|seq[(KeyCode, set[HIDModifiers])]
     ): ModifierMap =
  ##[

    Generate default modifier map

    For single-key chords: create all combinations of default modifiers
    and corresponding reports for this binding

    For multi-key shorts: create single final KeyResult and make it
    default. Any additional modifications need to be added explicitly.

  ]##
  let chords: seq[(KeyCode, set[HIDModifiers])] =
    when keybind is string:
      decodeKeybindingStr(keybindingStr)
    else:
      keybind

  if chords.len == 0:
    # Single key, generate all default keys
    discard
    for comb in @[@["default"]] & allSubsets(@["ctrl", "shift", "alt", "meta"]):
       let s = toHashSet(comb)
       # result[comb] =
  else:
    # Multiple keys, generate final chord
    discard


func toHIDReport*(press: KeyPress): HIDReport =
  result.modifiers = press.modifiers
  result.keycodes[0] = press.code

func toKeyPress*(code: KeyCode): KeyPress =
  if code.isModifier():
    result.modifiers.incl code.toHIDModifer()
  else:
    result.code = code

func toKeybindingStr*(key: KeyResult): string =
  ## Return key press result in form of emacs chord
  if key.isFinal:
    result = key.chord.mapIt(it.toHIDReport().toKeybindingStr).join(" ")
  else:
    result = key.adder.toHIDReport().toKeybindingStr()


func notDefaultModifier(modif: string): bool =
  return modif notin @["default", "ctrl", "shift", "alt", "meta"]


func toKeybindingStr*(key: ModifierMap): seq[string] =
  if key.hasKey(toHashSet(["default"])):
    result.add key[toHashSet(["default"])].toKeybindingStr()

  for it in key.keys():
    if anyofIt(it, it.notDefaultModifier()):
      result.add key[it].toKeybindingStr()



type
  Seq2D[T] = seq[seq[T]]
  Seq3D[T] = seq[seq[seq[T]]]

# IDEA add support for arranging string grids relative to ech other
# (above, below etc), centerin them in terminal and so on. Not
# full-blown curses-like graphics, just very simple string
# manipluations.

# IDEA add support for printing grid transitions - output two grid
# states and highlight changed keys.
proc printGrid*(grid: KeyGrid) =
  ## Print matrix keys as 2d array. Keys are mapped to emacs notation
  ## and. Multi-chord keys are mapped as multiple keypresses. NOTE:
  ## Currently only on-release events are printed.
  let matrix: Seq3D[string] = grid.keyGrid.mapIt(it.mapIt(
    it.onPress.toKeybindingStr()
  ))

  proc maxLen[T](s: Seq3D[T]): int =
    s.mapIt( # 3d
      it.mapIt( # 2d
        it.mapIt( # 1d
          it.len
        ).max()
      ).max()
    ).max()

  let colWidth = maxLen(matrix) + 2
  echo "+", matrix[0].mapIt("-".repeat(colWidth)).join("+"), "+"
  for row in matrix:
    static: assert row is Seq2d[string]

    let rowHeight: int = row.mapIt(it.len).max()
    for line in 0 ..< rowHeight:

      let lItems = row.
        mapIt((it.len <= line).tern("", it[line])).
        mapIt(center(it, colWidth))

      let lStr = "|" & lItems.mapIt($it).join("|") & "|"
      echo lStr

    let rSep = "+" & row.mapIt("-".repeat(colWidth)).join("+") & "+"
    echo rSep


proc updateKey*(key: var Key, isPressed: bool): bool =
  ## Transition between key states based on whether or not it is
  ## pressed
  # IDEA write macro for function that perform role of state automata.
  # Provide DSL for writing transition rules (base it on some language
  # that is related to automata)
  result = false

  case key.state:
    of kstIdleReleased:
      if isPressed:
        key.state = kstChangedPressed
        result = true # Key is now pressed

    of kstIdlePressed:
      if not isPressed:
        key.state = kstChangedReleased
        result = true # Key is not released

    of kstChangedPressed:
      if isPressed:
        key.state = kstIdlePressed
        # Key is still pressed, no changes

    of kstChangedReleased:
      if not isPressed:
        # Key is still released, no changes
        key.state = kstIdleReleased


proc hasDifferentValues[T](arr: seq[T]): bool =
  var sorted = arr
  sorted.sort()
  for idx, item in sorted[1 ..^ 1]:
    if sorted[idx] == item:
      return false

  return true

func makeKeyPress(
  code: KeyCode = ccKeyNone, modifiers: set[HIDModifiers]): KeyPress =
  ## Make single key press instance with key and modifiers
  var modifs: set[HIDModifiers]
  for m in modifiers:
    modifs.incl m
  KeyPress(code: code, modifiers: modifs)

func makeKeyResult*(
  chords: seq[tuple[code: KeyCode, modifs: set[HIDModifiers]]]
     ): KeyResult =
  if chords.len == 1:
    KeyResult(
      isFinal: false,
      adder: makeKeyPress(chords[0].code, chords[0].modifs)
    )
  else:
    KeyResult(
      isFinal: true,
      chord: chords.mapIt(makeKeyPress(it.code, it.modifs))
    )

const noMod*: set[HIDModifiers] = {}
proc makeKeyGrid*(
  codes: seq[seq[ # 2d grid
    seq[(KeyCode, set[HIDModifiers])] # Key configurations
  ]],
  rowPins, colPins: seq[int]
     ): KeyGrid =
  assert codes.len == rowPins.len
  assert codes[0].len == colPins.len
  assert rowPins.hasDifferentValues()
  assert colPins.hasDifferentValues()

  KeyGrid(
    keyGrid: codes.mapIt(
      it.mapIt(Key(
        state: kstIdleReleased,
        onPress: makeModifierMap(it))
      )),
    rowPins: rowPins,
    colPins: colPins)



proc parseGridConfig*(str: string): KeyGrid =
  let toml = str.parseString()
  assert toml.hasKey("rowPins")
  assert toml.hasKey("colPins")

  let codes: seq[seq[seq[(KeyCode, set[HIDModifiers])]]] =
    toml["row"].getElems().mapIt(
      it["keys"].getElems().mapIt(
        it.getStr().decodeKeybindingStr()))

  return makeKeyGrid(
    rowPins = toml["rowPins"].getElems().mapIt(it.getInt()),
    colPins = toml["colPins"].getElems().mapIt(it.getInt()),
    codes = codes
  )

proc updateKeyGrid*(grid: var KeyGrid, matrixState: seq[seq[bool]]): bool =
  ## Determine whether or not any change ocurred in grid (based on
  ## matrixState). Return true if at least one key chaged. Grid will
  ## be modified to match new state (key states will be updated)
  var anyChanges = false

  for rowIdx, rowState in matrixState:
    for keyIdx, keyState in rowState:
      let key = grid.keyGrid[rowIdx][keyIdx]
      let isChanged = grid.keyGrid[rowIdx][keyIdx].updateKey(keyState)
      # echo key.state, " -> ",
      #     grid.keyGrid[rowIdx][keyIdx].state, " ",
      #     key.onPress.toKeybindingStr()
      anyChanges = anyChanges or isChanged

  return anyChanges

proc createReports*(grid: KeyGrid): seq[HIDReport] =
  ## Generate report based on current grid status. Because some
  ## buttons might generate multiple keypresses (chord bindings)
  ## multiple hid reports are returned.
  # TODO comment case-of for key state switching
  var keys: seq[KeyCode]
  var accumulatedReport: HIDReport
  var currentModifiers: HashSet[string]
  for keyRow in grid.keyGrid:
    for key in keyRow:
      if key.state in @[kstChangedPressed, kstIdlePressed]:
        currentModifiers.incl key.modifiers

      case key.state:
        of kstChangedPressed, kstChangedReleased:
          # echo "key state is ", key.state
          let kResOpt: Option[KeyResult] = (key.state == kstChangedPressed).tern(
            key.getActivatedChord(currentModifiers, onPress = true),
            key.getActivatedChord(currentModifiers, onPress = false)
          )

          iflet (kRes = kResOpt):
            if kRes.isFinal:
              # TODO accept buffered modifiers
              # NOTE returning immediately on multi-chort button
              return kRes.chord.map(toHIDReport)
            else:
              accumulatedReport.modifiers.incl kRes.adder.modifiers
              # TODO account for multiple keys, use all six slots to
              # generate output event
              accumulatedReport.keycodes[0] = kRes.adder.code
          else:
            echo "No matching keybindings for ", currentModifiers
        else:
          discard

  return @[accumulatedReport]
