

== Requirements

* Raspberry pi zero
* 8+GB micro sd card
* Couple of usb wires

== Keyboard setup

=== Setup raspberry pi

Setup raspberry pi, connect to your wifi in headless mode
and ssh into it.

==== Install raspbian

*Burn Raspbian image*::
  ** Download the Raspbian jessie image from
     https://downloads.raspberrypi.org/raspbian_lite/images/raspbian_lite-2017-07-05/[here]
  ** Burn it on sd card using
  `sudo dd bs=4M if=<raspbian image> of=/dev/sdX conv=fsync`
*Cd to sd card*::
  ** Create mount point `sudo mkdir /mnt/sdcard`
  ** Mount sd card to previously created folder `sudo mount /dev/sdX2
     /mnt/sdcard` - mount root parition
  ** `cd /mnt/sdcard`
  ** `sudo mount /dev/sdX1 /mnt/sdcard/boot` - mount boot parition.

NOTE: Paritions numbers in `/dev/sdX1` and `/dev/sdX2` might differ.

IMPORTANT: After you flashed installation image to the sd card it
should have *two* partitions - first one is small (around hundred
megabyte) and second one taking up all remaining space. First one is a
boot parition, and it should be mounted to the `boot` directory of the
sd card.


*Enabling ssh*::
  ** Create a file named `ssh` in the root of the boot volume using
   `touch ssh`
  ** To preconfigure the Pi to connect to a WiFi network, create a
    file called wpa_supplicant.conf in the root of the boot volume
    with the following contents.


*Enabling Ethernet over usb*::
  ** Append `dtoverlay=dwc2` to the `config.txt` (`echo
     "dtoverlay=dwc2" | sudo tee -a boot/config.txt`)
  ** `echo "dwc2\ng_ether" | sudo tee -a etc/modules` _or_ Insert
     modules-load=dwc2,g_ether after rootwait in the
     `boot/cmdline.txt` file

NOTE: If you are completely paranoid you might check if everything is
set up correctly by executing `cd /mnt/sdcard/boot && grep -q
"modules-load=dwc2,g_ether" < cmdline.txt && echo "cmdline correct" &&
grep -q "dtoverlay=dwc2" < config.txt && echo "config correct"` in
terminal (this is a single command).

*Connecting to the RPI*::
  ** Make sure that `avahi-daemon` is up and running TODO how?
     ** For gentoo linux you can install and enable it using
        *** `sudo emerge --ask --tree --verbose net-dns/avahi`
        *** `sudo rc-service avahi-daemon start` - to start daemon
        *** `sudo rc-service avahi-daemon enable` - to enable daemon
            on startup
     ** To check whether or not your raspberry has been detected by
        avahi daemon you can run `avahi-browse -atr | grep -A 4
        raspberry`
  ** Connect to raspberry pi using `ssh pi@raspberry.local`. Default
     credentials are
     *** `username: pi`
     *** `password: raspberry`

Dealing with errors::
  ssh: connect to host localhost port 22: Connection refused:::
    * If `ssh localhost` giving you the same error it is likely that
      ssh daemon is not running. You can start it using `sudo
      rc-service sshd start` or `sudo systemctl start sshd.service`

./boot/cmdline.txt
****
The Linux kernel accepts a command line of parameters during boot. On
the Raspberry Pi, this command line is defined in a file in the boot
partition, called cmdline.txt. This is a simple text file that can be
edited using any text editor, e.g. vi.

`sudo vi /boot/cmdline.txt` (or `sudo vi boot/cmdline.txt` if you have
RPI sd card mounted in different PC)

Be careful with this file, it is very picky with its formatting! Each
parameter is seperated by a single space (it does not use newlines).

Unmodified content of the cmdline.txt: `dwc_otg.lpm_enable=0
console=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2
rootfstype=ext4 elevator=deadline rootwait` and after modifications it
should look like this: `dwc_otg.lpm_enable=0 console=serial0,115200
console=tty1 root=PARTUUID=00f1f24d-02 rootfstype=ext4
elevator=deadline fsck.repair=yes rootwait modules-load=dwc2,g_ether`
****

./etc/modules
****
The /etc/modules file contains the names of kernel modules that are to
be loaded at boot time, one per line. Arguments can be given in the
same line as the module name. Lines beginning with a `#` are ignored.
****

./boot/config.txt
****
The Raspberry Pi uses a configuration file instead of the BIOS you
would expect to find on a conventional PC. The system configuration
parameters, which would traditionally be edited and stored using a
BIOS, are stored instead in an optional text file named config.txt.
This is read by the GPU before the ARM CPU and Linux are initialised.
It must therefore be located on the first (boot) partition of your SD
card, alongside bootcode.bin and start.elf. This file is normally
accessible as /boot/config.txt from Linux, and must be edited as root.
****


*Enabling Wifi*::
----
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=<TWO_LETTER_ISO_COUNTRY_CODE>

network={
    ssid="<WIFI_NETWORK_NAME>"
    psk="<WIFI_PASSWORD>"
    key_mgmt=WPA-PSK
}
----

* Unmount sd card using `sudo umount /mnt/sdcard`, eject it and insert
  it into the Raspberry PI. When unmounting make sure that you are not
  in the same folder because this might cause `umount: /mnt/sdcard:
  target is busy` error. If you want to force unmount sd card you
  might use `-l` option.

==== Install required packages

Before proceding with packages that are mandatory for installation I
recommend you to spent ~10 minutes of your time and make your life
much more comfortable by installing `fish` and `neovim`. Of course you
can choose any other text editor and shell. To use vim under sudo and
still have all your settings use `sudo -E nvim`

Installation as follows:
----
sudo apt-get install neovim zsh
# Last one is optional: download and isntall my vim config: very minimalistic (only 18 lines).
# You can replace it any other config you want
mkdir -p ~/.config/nvim/
curl https://gitlab.com/snippets/1770471/raw >> ~/.config/nvim/init.vim
----


== Devnotes

=== USB Hid


Input reports are those sent from the keyboard to the computer.

* 1 byte: modifier keys (Control, Shift, Alt, etc.), where each bit
  corresponds to a key
* 1 byte: unused/reserved for OEM
* 6 bytes: pressed key codes

In order to press a regular key (e.g. A or B), its code has to be
included inside the 6 byte segment. Remember that this segment
represents the pressed keys, so until a key stops appearing there the
host will keep pressing that key constantly.

The modifier keys, however, are 1 bit each. The modifier byte has the
following structure (bit 0 is on the rightmost part):

1. Right Meta
2. Right Alt
3. Right Shift
4. Right Control
5. Left Meta
6. Left Alt
7. Left Shift
8. Left Control

If a given bit is set to 1, then the modifier key in
question is pressed.

=== General algorithm

==== In short

Scan all keyboard, if any changes in pressed keys form new usb report
and send it to PC.

==== More detailed

Main algorithm is divided into several stages.
. Scan all keypads to determine which keys has been changed.
. If no keys changed between scans do nothing
. For each changed key
  ** If this key has controlled some of the modifiers determine
      whether or not this modifier is still activated by some other key.
      If this is not the case toggle modifier off.
  ** After determining which modifers are activated on this keypad
      add modifiers from other keypads.
  ** For each pressed key determine key code that will be sent to the
      PC.
. After previous stage we have
  1. List of currently pressed modifier keys
  2. List of key codes that should be sent to the PC

  Create report that will be sent to the pc

----
/--------------------------\
| 8-bit modifier key codes |
+--------------------------+
| OEM reserved             |
+--------------------------+
| Key code                 |
+--------------------------+
| Key code                 |
+--------------------------+
| Key code                 |
+--------------------------+
| Key code                 |
+--------------------------+
| Key code                 |
+--------------------------+
| Key code                 |
\--------------------------/
----


=== Python HUD interactions

----
def write_report(report):
    with open('/dev/hidg0', 'rb+') as fd:
        fd.write(report.encode('latin1'))
----


****
The HID Gadget driver provides emulation of USB Human Interface
Devices (HID). The basic HID handling is done in the kernel, and HID
reports can be sent/received through I/O on the /dev/hidgX character
devices.
****

== Links

Links to articles and forum discussions that I found to be really useful
when making this keyboard

*
  https://www.rmedgar.com/blog/using-rpi-zero-as-keyboard-send-reports[RPI
  as keyboard send reports]
*
  https://medium.com/@maheshsenni/setting-up-a-raspberry-pi-without-keyboard-and-mouse-headless-9359e0926807[Setting
  up a Raspberry Pi without keyboard and mouse (headless)]
